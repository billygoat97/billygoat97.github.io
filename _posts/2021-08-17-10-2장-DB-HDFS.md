---
title: "데이터베이스(DB) 10-2장 하둡 파일 시스템"
except: "데이터베이스(DB) 에서 빅 데이터를 저장 및 읽기에 이용되는 HDFS에 대해 알아보자."
categories:
  - 데이터베이스
tags:
  - 하둡
  - HDFS
  - 네임 노드
  - 보조 네임 노드
  - FsImage
  - EditLog
toc: true
toc_sticky: true
---

# 10-2장 HDFS (하둡 파일 시스템)
## <span style = "color:powderblue"> ※ 하둡 에코시스템의 코어 프로젝트인 HDFS이란?

### <span style = "color:powderblue"> ※ 설계 목표
- 장애 복구
	- HDFS는 장애를 쉽게 감지하고 대처할 수 있게 설계
	- 데이터 저장시 복제 데이터도 저장 (데이터 유실 방지)
	- 분산 서버 간에 주기적으로 상태 체크해 장애 인지 대처
- 스트리밍 방식의 데이터 접근
	- HDFS에 저장 조회시, 스트리밍 방식으로 접근
	- 배치 작업 최적화하여 접근 시간보다는 데이터 처리량에 중점

- 대용량 데이터 저장
	- HDFS는 하나의 파일이 기가~ 테라까지의 큰 사이즈
	- 높은 데이터 전송 대역폭과 클러스터별 수백대의 노드 지원 가능
	- 하나의 노드에서 수백만개의 파일 지원
- 데이터 무결성
	- 한번 저장한 것을 수정 불가능, 읽기만 가능
	- 파일 읽기 복제 삭제는 가능해서 수정처럼 할 수 있음
	- 최근에는 append도 가능 (지우는거 빼고는 가능)
<br><br><br>

### <span style = "color:powderblue"> ※ HDFS 구조
- 블록 구조 파일 시스템
- 특정 사이즈의 블록으로 파일 나눠서 분산 서버 저장
- 블록 사이즈는 64MB(but 변경 가능)
- 분산 서버에 저장하기 때문에 로컬 서버의 하드디스크보다 더 큰 데이터 저장 가능
- 스트리밍 방식으로 순차적으로 검색 가능
- 블록을 저장할 때 기본적으로 3개씩 블록의 복제본을 저장함 (갯수는 변경 가능)

![image](/images/DB-10(2)-01.png)

-  HDFS는 마스터와 슬레이브 아키텍처로 구성
- 마스터 역할의 네임노드 서버 1개, 슬레이브의 데이터 노드 서버 여러 배
- 네임 노드는 모든 데이터를 관리하여 클라이언트가 HDFS 파일에 접근 도와줌
- 블록으로 나눠진 데이터는 여러 대의 데이터 노드에 분산 저장
- 사용자 구현 애플리케이션은 HDFS에 파일 저장, 읽기 위해 클라이언트를 이용하며 API의 형태로 사용자에게 제공
![image](/images/DB-10(2)-02.png)

- 계층형 파일시스템을 지원하기 때문에 HDFS에 디렉토리를 만들고 파일 저장 가능
- 디렉토리명과 파일명이 같은 네임스페이스는 네임노드와 메타 데이터에 저장
- 복제본의 수와 블록 위치도 메타 데이터에서 관리
- 데이터 노드는 주기적으로 네임노드에게 하트 비트와 블록의 목록 저장된 블록 리포트 보내줌
- 네임노드는 하트 비트를 통해 데이터 노드 동작 확인
- 네임 노드는 블록리포트를 통해 모든 블록 확인, 복제본 위치 결정
- 클라이언트는 네임 노드에 접속해 원하는 파일이 저장된 블록의 위치 조회, 해당 블록이 저장된 데이터 노드에서 직접 데이터 조회

<br><br><br>

### <span style = "color:powderblue"> ※ 파일 저장

![image](/images/DB-10(2)-03.png)

- 동작 방식은 위와 같다
1. 사용자 어플리케이션이 클라이언트에게 파일 저장을 요청
2. 클라이언트는 네임 노드에게 파일 경로 생성 요청
3. 네임 노드는 파일 경로 존재시 에러 반환, 아니면 파일 경로 생성 후, 변경 못하게 lock
4. 네임 노드는 클라이언트에게 파일 저장할 데이터 노드 목록 제공(블록 복제 개수 만큼)
5. 클라이언트는 첫 데이터 노드에게 데이터 전송
6. 데이터 노드는 전송 받은 데이터를 로컬 디스크 저장한 후, 다음 데이터 노드로 데이터 전송
7. 다음 데이터 노드도 로컬에 저장후 세 번째로 전달
8. 세 번째도 저장
9. 두세번째는 첫 번째에게 다했다고 알려줌
10. 첫 번째 노드는 클라에게 저장 완료됨을 응답
11. 클라는 어플에게 저장 완료됨을 응답

<br><br><br>

### <span style = "color:powderblue"> ※ 파일 읽기

![image](/images/DB-10(2)-04.png)
- 파일읽기은 위와 같음
1. 어플리케이션이 클라이언트에게 파일 읽기 요청
2. 클라이언트는 네임 노드에게 어플리케이션이 요청한 파일이 어떤 블록에 저장되어 있는지 블록 위치 정보 요청
3. 네임 노드는 패당 복제블록 위치를 메타 데이터를 통해 확인 후 해당 데이터 노드의 목록을 반환, 데이터 노드는 클라이언트와 가까운 순서대로 정렬됨
4. 클라이언트는 데이터 노드에게 블록 조회 요청
5. 데이터 노드는 클라이언트에게 데이터 전송
6. 클라이언트는 어플리케이션에게 전송 받은 데이터 전달
<br><br><br>

### <span style = "color:powderblue"> ※ 보조 네임노드
- 네임노드는 HDFS 메타 데이터 관리 위해 에디트 로그(EditLog)와 파일 시스템 이미지 파일(FsImage) 사용
- 에디트 로그는 HDFS 메타 데이터에 대한 모든 변화 기록 로그 파일. 네임 노드의 로컬 파일 시스템에 파일 저장
- HDFS에 새 파일 저장, 삭제, 위치 변경은 모드 에디트 로그에 저장
- 파일 시스템 이미지 파일은 파일 시스템의 네임 스페이스(디렉토리명, 파일명, 상태 정보)와 파일에 대한 블록 매핑 정보를 저장하는 파일. HDFS 스냅샷. 네임 노드의 로컬 파일 시스템에 파일로 저장
- 네임 노드가 구동시에 파일 시스템 이미지와 에디트 로그의 변화;
1. 로컬에 저장된 FsImage, EditLog를 조회
2. 로그 파일 내용 바탕으로 메모리 올라와 있는 파일 시스템 이미지 갱신
3. 메모리에 파일 시스템 이미지를 로컬 파일 시스템 이미지 파일에 적용
4. 에디트 로그 파일 초기화
- 보조 네임 노드는 체크포인팅이라는 작업을 통해 네임 노드 에디트로그 크기 줄임
- 따라서 보조네임노드의 다른 이름은 체크포인터 서버라고도 함 (보조 네임 노드 != 네임 노드 백업 서버)
<br><br><br>
<br><br><br>


# <span style = "color:Yellow">**※ 핵심 내용**
## <span style = "color:Orange"> **Q1 . 하둡 파일 시스템의 설계 목표 4가지는 무엇이고 이를 간단히 설명하라** </span>

- 하둡 파일 시스템의 설계 목표는 장애복구, 스트리밍 방식의 데이터 접근, 대용량 데이터 저장, 데이터 무결성이다. 장애 복구는 데이터를 저장할 때 복제 데이터도 저장함으로 데이터 유실을 막고 분산서버간에 주기적으로 상태 체크 및 대처를 한다. 스트리밍 데이터 접근은 조회할 때 이용되는 방식으로, 파일 접근 시간보다는 높은 데이터 처리량에 중점을 둔다. 대용량 데이터 저장은 하나의 파일이 테라바이트이상의 사이즈이며 수백만개의 파일은 하나의 노드, 수백대의 노드는 하나의 클러스터를 구성하고 있다. 데이터 무결성은, 저장한 정보를 수정하지 못한다는 점이 있다. 그러나 삭제 복제는 가능하며 append 또한 가능하다.

## <span style = "color:Orange"> **Q2 . HDFS 구조를 설명하라** </span>

- HDFS는 블록 구조의 파일 시스템으로 한번에 저장할 때 3개씩 복제 블록을 저장한다. HDFS는 마스터와 슬레이브 아키텍처로 구성되어있는데, 전체 컨트롤하는 마스터 네임 노드 서버가 한 대, 슬레이브 데이터 노드 서버가 여러대로 구성되어 있다. 네임 노드는 모든 메타 데이터를 관리하며 클라이언트의 요청을 처리하게 해준다. 데이터 노드들은 블록 형태의 데이터를 분산하여 저장하게 된다. 디렉토리명과 파일명같은 네임스페이스는 네임노드에 저장되며, 복제본의 수, 위치도 네임노드에 저장된다. 데이터 노드는 주기적으로 네임노드에게 블록의 목록과 하트 비트가 저장된 블록 리포트를 보내주며 네임 노드는 하트 비트로 데이터 노드 상태를 확인한다. 또한 블록 리포트를 통해 모든 블록을 확인하며 복제본 위치를 결정하게 된다. 클라이언트는 네임노드를 통해 데이터 노드의 위치를 조회, 해당 블록이 저장된 데이터노드에서 직접 조회하게 된다.

## <span style = "color:Orange"> **Q3 . HDFS file 저장을 사용자 어플리케이션부터 시작해서 과정을 설명하라** </span>

- 사용자 App이 cli에게 파일 저장을 요청하면, 파일 경로를 생성 가능한지 네임노드에게 체크를 하며, 기존에 존재시 에러 체크, 아니면 생성하여 lock을 건다. 네임 노드는 클라이언트에게 데이터 노드 목록을 반환하며, 클라이언트는 첫 번째 데이터노드에게 데이터를 전송한다. 첫 번쨰 노드는 자기 로컬에 저장, 두 번째 노드에게 전달하며 두 번째도 그렇게 하고 세 번째로 전달한다. 세 번쨰와 두 번째는 완료시에 첫 번째에 응답을 하고, 클라이언트에게 응답을 하게 된다. 이 모든 과정이 끝난 후에 클라이언트는 APP에게 파일 저장 완료했음을 알려준다.

## <span style = "color:Orange"> **Q4 . HDFS file read를 사용자 어플리케이션부터 시작해서 과정을 설명하라** </span>

- 파일 읽기는 APP이 cli에게 요청하며, 네임노드에게 해당 파일이 어떤 블록에 있는지 문의함. 네임 노드로부터 데이터 노드 목록이 담긴 정보를 가져오면, 클라이언트는 데이터노드들에게 블록 조회를 요청하며 데이터를 전송받는다. 이를 통해 클라이언트는 APP에게 전송 받은 데이터를 전달하게 된다.


## <span style = "color:Orange"> **Q5 . FsImage 와 EditLog의 용도를 설명, 보조 네임노드가 이를 어떻게 활용하는지 설명하라** </span>

- EditLog는 에디트 로그로, 메타 데이터의 모든 변화를 기록하는 로그 파일로 네임 노드 로컬에 저장되며, FsImage는 파일 시스템 이미지로 네임스페이스와 블록 매핑 정보가 있으며 네임 노드 로컬에 저장된다. 네임 노드가 구동할 경우에는 FsImage, Edilog를 조회하여 에디트 로그 파일에 있는 내용 바탕으로 메모리 파일 시스템 이미지를 갱신한다. 그 이후 메모리에 있는 FsImage를 로컬에 있는 파일 시스템 이미지 파일에 적용하며, 로그 파일을 초기화한다. 보조 네임노드는 체크포인팅 과정을 통해 에디트로그 양을 줄이려고 하며, 이는 주기적으로 editlog 내용을 반영하는 것이다.